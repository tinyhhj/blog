---
title: "Spring Chap. 6"
date: "2020-01-04T16:00:39.375Z"
description: "Toby Spring"
---

# AOP

## 프록시

서비스 추상화를 통해서, 트랜잭션을 적용하는 내용을 데이터 액세스 기술에 관계없이 적용할 수 있게끔 `전략패턴`으로 분리 시켰지만,
비지니스 로직자체에 트랜잭션을 적용시키는(부가기능) 코드는 그대로 남아있다. 트랜잭션을 적용시키는 부분까지도 비지니스 로직에서 제거하기 위해서
인터페이스를 통해 구현부분을 분리시켜 `부기가능`이 `핵심기능`을 사용하도록 구조를 만든다.

여기서 주의할 점은 클라이언트가 직접 `핵심기능`을 사용하지 못하도록 `부가기능`이 마치 `핵심기능`인것처럼 꾸며 클라이언트의 요청을 가로채야 한다는 사실이다. 여기서 `부가기능`은 프록시, `핵심기능`은 타겟이라고 부른다.

프록시는 두가지로 구분할 수 있는데

1. 클라이언트가 타겟에 접근하는 방법을 제어하기 위해서
2. 타겟에 부가적은 기능을 부여해주기 위해서

각각을 목적에 따라 디자인 패턴에서는 다른 패턴으로 구분한다.

## 데코레이터 패턴

부가기능을 부여하기 위해서 프록시를 사용하는 패턴이다. 프록시를 여러개를 사용해 각각 다른 부가기능을 타겟 기능에 부여할 수 있다.

예) 선물포장하기

선물포장요청-> 리본묶기 -> 포장지 감싸기 -> 선물

## 프록시 패턴

타겟에 접근하는 방법을 제어하기 위해서 사용하는 패턴이다. **프록시 패턴의 프록시는 타겟의 기능을 확장하거나 추가하지 않는다.**

예) lazy init

1. 타겟이 당장 쓰이지 않지만, 참조값이 필요할 때 프록시를 미리 생성해두고 클라이언트가 프록시를 통해 메소드를 호출할 때, 타겟을 생성해서 요청을 위임한다. 즉, 타겟을 직접 사용할 때까지 최대한 생성을 늦춘다.

2. 원격 오브젝트에 대한 접근방법을 제공해줄 때 사용할 수 있다. 원격 오브젝트에 대한 프록시를 만들어두고 클라이언트는 마치 로컬 오브젝트에게 요청하듯이 작업을 요청하고, 프록시는 내부에서 원격오브젝트를 실행하여 결과를 돌려주는 식이다.

3. 타겟에 대한 접근권한을 제어하기 위해서도 사용할 수 있다.

예) Collections.unmodifiableCollection

데코레이터와 프록시는 유사해보이지만, 생성을 지연하는 프록시의 경우 구체적인 생성 방법을 알아야하므로 타겟에 대한 구체적인 정보를 알고 있는 경우가 많다.

## 프록시 작성의 문제점

1. 타겟의 인터페이스를 구현하는게 번거롭다. 단순 위임형식이어도 일일이 코드를 작성해야하고, 타겟의 메소드가 추가되거나 변경될 경우 함께 수정해야한다.
2. 부가기능 코드가 중복될 가능성이 많다. 각 메소드마다 부가기능이 들어간다면 부가기능은 각각 메소드마다 항상 중복되어 나타나게 된다.

## 다이나믹 프록시

`프록시 팩토리`에 의해서 런타임 시 다이나믹하게 만들어지는 객체이다. 타겟의 메소드 수가 몇개이던 상관없이 타겟 인터페이스의 정보와 프록시 메소드 호출 시 실행되는 `InvocationHandler`만 구현하면 프록시 적용이 가능하다. 또한 타겟의 적용 대상이 제한되있지 않으므로 재사용성이 높다.

예) 리턴 타입이 string인 것만 uppercase적용, 메소드 이름이 say로 시작하는 경우에만 uppercase 적용

**주의**
InvocationHandler를 구현할 때, 타겟의 Exception은 InvocationTargetException으로 감싸져 던져지므로 InvocationTargetException으로 캐치를 한뒤 , getTargetException으로 해당 예외처리를 해야한다.

## 다이나믹 프록시 문제점

다이나믹 프록시와 InvocationHandler를 통해서 프록시를 적용할 수 있으므로, 프록시를 스프링 DI를 통해 주입시킬 수 있어야한다. 하지만 **DI의 대상이 되는 다이나믹 프록시 객체는 클래스 명이 없으므로 일반적으로 DI될 수 있는 방법이 없다**

> 스프링의 빈을 만드는 방법은 클래스의 디폴터 생성자를 이용하는 방법 이외에도 여러가지 방법을 제공하는데 그 중 하나가 `팩토리 빈`을 이용하는 방법이다.
> `팩토리 빈`을 만드는 방법에는 여러가지가 있는데 가장 간단한 방법은 FactoryBean 인터페이스를 구현하는것이다.

### 팩토리 빈

팩토리 빈의 등록방법은 여타 빈의 등록방법과 다르지 않다. 아래 예제에서 등록되는 aaa의 빈의 경우 FactoryBean의 객체가 등록되는것이 아닌
FactoryBean의 getObject 메소드가 생성해주는 객체가 aaa빈으로 등록이되며, 타입은 팩토리 빈의 getObjectType이 리턴하는 타입으로 결정된다.

```xml
<bean id ="aaa" class="factoryBeanclass">
    <property name="bbb" value="testString">
</bean>
```

- 팩토리 빈은 빈 이름앞에 `&`를 붙여주면 얻을 수 있다.
- 팩토리 빈은 빈을 생성할 때 필요한 정보들을 프로퍼티로 가지고 있다가, 빈을 생성할 때 해당 프로퍼티를 전달하면서 객체를 생성한다.

**즉 프록시를 생성하는 팩토리 빈과 타겟을 빈으로 등록하여 프록시를 빈으로 등록하여 사용할 수 있다.**

## 팩토리 빈의 장점과 한계

### 장점

프록시 팩토리 빈의 장점은 타겟에 제한없이 재사용이 가능하다는 점이다. 또한 다이나믹 프록시의 문제점 2가지 일일이 메소드를 구현해야한다는 점과,
부가기능의 코드가 메소드마다 중복되어 나타나는 문제점을 `프록시 팩토리 빈`으로 해결할 수 있다.

### 한계

1. 한번에 여러 클래스에 공통적인 부가기능을 제공하는 것은 불가능하다. (하나의 클래스는 가능, 즉 여러개의 팩토리 빈 설정이 중복) - 200개의 클래스에 여러 부가기능을 적용시키려면 200 \* 부가기능갯수 만큼의 팩토리 빈 설정이 필요
2. InvocationHandler는 타겟 객체를 프로퍼티로 지니고 있으므로, 프록시 팩토리 빈 갯수만큼 만들어진다.

## 프록시 팩토리 빈

jdk에서는 다이나믹 프록시 외에도 프록시를 만들 수 있도록 다양한 기술을 지원한다. 따라서 스프링은 일관된 방법으로 프록시를 만들 수 있게끔 추상화 된 레이어를 제공한다.

### MethodInterceptor vs InvocationHandler

invocationHandler.invoke는 타겟에 대한 정보를 제공하지 않기 때문에 직접 invocationHandler가 타겟을 알고 있어야 하지만, MethodInterceptor의 invoke는 proxyFactoryBean으로부터 타겟 정보도 제공받으므로, MethodInterceptor의 경우 타겟과 독립적으로 만들어지고,사용될 수 있다.

타겟으로부터 독립될 수 있다면 MethodInterceptor는 타겟에 독립적으로 빈으로 등록되어 여러 타겟이 공유할 수 있다(싱글톤 패턴)
포인트컷 역시 타겟에 독립될 수 있다면 빈으로 등록되어 여러 타겟이 공유할 수 있다(싱글톤 패턴)

```
중복 문제의 접근 방법
1. jdbc api를 사용하는 dao 코드에서 메소드 마다 try/catch/finally 블록 중복 발생
    - 바뀌는 부분과 바뀌지 않는 부분으로 분리, 템플릿/콜백 패턴으로 해결
2. 반복적인 위임 코드가 필요한 프록시
    - 다이나믹 프록시라는 런타임 코드 자동생성 기법 사용하여 해결
```

### 팩토리 빈의 한계를 스프링 프록시 팩토리 빈으로 개선

1. 팩토리 빈의 문제상황 인지
   1. 한번에 여러 클래스에 부가기능 제공 불가능
   2. InvocationHandler는 타겟을 의존하고 있으므로, 타겟 적용 갯수만큼 늘어남
2. 문제상황을 어떻게 해결할지 고민
   1. 한번에 여러 클래스에 부가기능 제공 불가능에서 변하는 부분과 변하지 않는 부분을 설정
      - 변하는 부분: 부가기능을 적용할 실제 타겟
      - 변하지 않는부분: 타겟의 타입에 맞는 프록시 생성 작업
      - 고려 방향: 부가기능을 적용할 실제 타겟의 리스트를 주입받아 프록시 생성 작업을 자동으로 할 수 있다면?? => 빈 후처리기
   2. InvocationHandler는 타겟을 의존하고 있으므로, 중복해서 발생하는 문제
      - 변하는 부분: 실제 부가기능을 적용할 타겟
      - 변하지 않는 부분: 적용할 부가기능
      - 고려 방향: 타겟을 주입받아서 부가기능을 적용시킬 수 있다면?? => 어드바이스, 포인트 컷

## 빈 후처리기

빈 후처리기는 빈 설정파일을 통해 생성된 빈 객체들을 조건에 맞게 수정하거나, 대체할 수 있다.

### DefaultAdvisorAutoProxyCreator 동작 원리

1. 등록된 빈중에서 Advisor를 구현한 객체들을 모두 찾는다.
2. 생성되는 모든 빈에 대해서 어드바이저 포인트컷의 적용대상일 경우 프록시를 만들어서 원래 빈을 대체한다.

### AspectJ 포인트컷 표현식

AspectJ 표현식의 대상을 표현하는데 다양한 방법이 있다.

1. execution - 메소드의 시그니처를 비교하는 방식 (ex: Object.class.getMethod("getClass"))
2. bean - 빈이름으로 대상을 설정 (클래스와 메소드기준을 넘어섬)
3. @annotation - 특정 어노테이션으로 대상을 설정(ex: @anootation(org.springframework.transaction.Transactional))

> 주의점: AspectJ 포현식의 타입패턴의 경우 객체의 클래스만을 비교하는것이 아닌 객체의 모든 타입을 비교하여 대상을 결정한다.

> ex: A->B(C) [A: 자식 클래스 , B: 부모 클래스, (C): 부모 인터페이스] 라고할때 클래스 명으로 대상을 정할때 A 객체는 A타입이기도하면서 B 타입이기도 하며, C타입이기도 하다. 따라서 클래스 명 조건이 A,B,C중에 하나라도 적용된다면 대상에 포함된다.(AspectJ 타입패턴에 한해)

## 리마인드

1. 서비스 추상화
   비지니스 로직에 트랜잭션 경계설정 -> 트랜잭션 기술에 종속적인 코드 발생 -> 서비스 추상으로 일관된 경계설정(트랜잭션 구현기술 DI)
   추상화란: 인터페이스와 DI를 통해 `무엇을 하는지는(추상흐름)` 남기고 `어떻게 하는지(구체적 구현)`를 분리한것
2. 데코레이션 패턴
   비지니스 로직에 트랜잭션 경계설정 코드 혼재 -> 데코레이션 패턴으로 분리
3. 다이나믹 프록시 & 프록시 팩토리 빈
   데코레이션 패턴을 적용하기 위해서 모든 메소드 구현 및 트랜잭션(부가기능) 중복발생 -> 다이나믹 프록시 적용 -> 여러 클래스에 적용할 때 중복 발생 -> 프록시 팩토리 빈(프록시 기술 추상화) 적용 -> 어드바이스, 포인트컷을 타겟에 독립적으로 사용 가능
4. 자동 프록시 생성
   트랜잭션 적용 대상마다 프록시 팩토리 빈 적용하여 중복 발생 -> 빈 후처리기 적용 -> AspectJ를 통한 포인트컷 표현식 적용

## AOP 용어

- 타겟 - 부가기능을 적용할 대상
- 어드바이스 - 부가기능
- 조인포인트 - 어드바이스가 적용될 수 있는 위치(프록시의 경우 메소드 실행단계)
- 포인트컷 - 조인포인트를 선별하는 작업 혹은 모듈
- 프록시 - 클라이언트와 타겟 사이에서 요청을 대신 받아 타겟에 위임하면서 부가기능을 부여하는 객체
- 어드바이저 - 포인트컷 + 어드바이스(스프링 aop 용어, 단순한 애스팩트)
- 애스팩트 - aop의 기본모듈

### 프록시 AOP 준비작업

1. 자동 프록시 생성기 - DefaultAdvisorAutoProxyCreator
2. 어드바이스
3. 포인트컷
4. 어드바이저

## 트랜잭션

### 전파

1. PROPAGATION_REQUIRED: 진행중인 트랜잭션이 있으면 참여하고 없으면 새로 시작한다.
2. PROPAGATION_REQUIRES_NEW: 항상 새로운 트랜잭션 시작
3. PROPAGATION_NOT_SUPPORTED: 진행중인 트랜잭션에 관계없이 트랜잭션 없이 동작(aop 포인트컷 대상을 추출해내기 힘들때 모두 트랜잭션 적용 후, 따로 처리하는 방식)

### 격리수준

1. ISOLATION_DEFAULT: Datasource의 설정되어 있는 격리수준을 그대로 따른다.

### 제한시간

### 읽기전용

### transactionInterceptor

```
예외처리: 스프링의 기본적인 예외처리 원칙은 비지니스적인 의미가 있는 경우에 체크예외를 사용하고, 그 외의 복구 불가능한 순수한 예외의 경우는 런타임 예외로 포장해서 전달한다.
```

트랜잭션의 속성들을 메소드 패턴에 따라 다르게 지정할 수 있다.
스프링의 기본적인 예외처리를 따르지 않을경우에 `transactionAttribute의 rollbackOn`을 이용할 수 있다.

### 적용순서

1. 포인트컷에 의해서 트랜잭션 적용 대상들을 결정한다(타입패턴이나 빈이름을 이용)
2. 상세 메소드는 transactionInterceptor의 transactionAttribute를 이용해서 트랜잭션 속성을 메소드 패턴에 맞게 결정한다.

### @Transactional

1. @Transactional 어노테이션을 속성정보로 사용하도록 지정하면 @Transactional이 부여된 모든 오브젝트를 자동으로 타겟으로 인식한다.
   이때 사용되는 포인트컷은 `TransactionAttributeSourcePointcut`이다.
2. 대체정책: 클래스 메소드 -> 클래스 -> 인터페이스 메소드 -> 인터페이스 순으로 트랜잭션 속성을 참조한다.
3. @Transactional의 위치는 인터페이스를 사용하는 프록시 방식의 aop가 아닌경우에, 무시될 수 있으므로 `타겟 클래스에 적용`할 것을 권장한다.
