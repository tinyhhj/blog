## 3장

### 서비스 간 통신 시 고려사항
    - 일대일, 일대다
    - 동기, 비동기
### 1:1 상호작용
    - 요청/응답
    - 비동기 요청/응답
    - 단방향 알림
### 1:n 상호작용
    - 발행/구독
    - 발행/비동기 응답
### ipc에 따른 api 내용
    * 메시징
        - 메세지 채널
        - 메세지 타입
        - 메세지 포맷
    * rest
        - url
        - http method
        - 요청/응답 포맷
### rpi: 요청/응답 방식의 IPC, 메시징 방식과 달리 응답이 제때 도착한다는 가정
    * rest
        * 장점:
            - 단순하고 익숙함
            - postman/curl 간단히 테스트 가능
            - 요청/응답 통신을 직접 지원
            - http 방화벽 친화적
            - 중간 브로커가 없기때문에, 아키텍쳐 단순화
        * 단점:
            - 요청/응답 스타일만 지원
            - 가용성이 떨어짐, 중간에서 메세지 버퍼링을 돕는 매개자 없이 클라이언트/서버가 직접 통신하기때문에, 교환이 일어날 때에 동시에 실행 중이어야 함.
            - 서비스 위치를 클라이언트가 알고 있어야함. 서비스 디스커버리 메커니즘을 이용해서 단점보완 가능
            - 한번의 요청으로 여러 리소스 가져오기 힘듦
            - 다중 업데이트 작업을 http method로 나타내기 어려울 때 있음
    * grpc
        * 장점
            - 다양한 업데이트 작업이 포함된 api 설계하기 용이
            - 큰 메세지를 교환할때, 효율적임
            - 양방향 스트리밍으로 RPI, 메시징 두가지 통신방식 지원
            - 다양한 언어로 연동 가능
        * 단점
            - 클라이언트가 rest 기반 api보다 복잡해짐
            - 구형 방화벽은 http/2를 지원하지 않음
    * 부분 실패 처리: rest, grpc처럼 동기 통신하는 메커니즘의 경우 부분 실패시 처리 필요
        * RPI 프록시 설계
            - 네트워크 타임아웃
            - 미처리 요청(outstanding request) 갯수 제한
            - 회로 차단기 패턴
                - 성공/ 실패 갯수를 지표로 임계치가 넘으면 서비스 차단, 일정 시간 이후 재시도시 성공하면 해제
    * 서비스 디스커버리
        - rest api를 호출하려면 서비스의 위치(url)을 알고 있어야 하나, 클라우드 기반의 마이크로 서비스는 네트워크 위치가 훨씬 동적이라서 식별하는 일이 쉽지 않음
        - 서비스 인스턴스가 시작/종료시 마다 서비스 레지스트리 업데이트
        - 구현방법
            - 클라이언트/서비스가 직접 서비스 레지스트리와 상호작용
                - 자가등록 패턴: 서비스가 스스로 레지스트리에 자기자신을 등록
                - 클라이언트 사이드 디스커버리: 클라이언트에서 서비스 레지스트리를 조회한 뒤, 부하분산
            - 배포 인프라로 서비스 디스커버리 처리
                - 서드파티 등록 패턴: 배포 플랫폼 컴포넌트 서비스 등록기가 별도 존재하고, 서비스 감시 및 레지스트리에 등록
                - 서버 사이드 디스커버리: 클라이언트는 dns로 서비스 요청하면, 배포 컴포넌트의 라우터가 서비스 레지스트리 조회 후, 요청을 해당 서비스에 라우팅
### 비동기 메세징: 서비스 간 중개 역할을 하는 메세지 브로커가 존재하지만, 직접 통신하는 “브로커리스” 아키텍쳐도 존재, 동기방식 RPI와 달리 클라이언트는 응답을 바로 받지 못할 것이라는 전제하에 작성
    * 메시징 통신 구성
        * 메세지
            * 구성
                - 헤더: 
                    - 송신 데이터의 메타 데이터
                    - 송신자, 메세지 id, 응답이 출력될 메세지 채널 주소 등..
                - 본문
                    - 송신 데이터: 이진/텍스트
            * 종류
                - 문서 : 데이터 해석은 수신자가 결정
                - 커맨드 : rpc요청과 동등한 메세지, 호출 작업,전달할 매개변수가 지정되어 있음
                - 이벤트: 송신자에게 어떤 이벤트가 발생했음을 알리는 메세지, 대부분 Order,Customer 같은 도메인 객체의 상태 변화를 나타내는 도메인 이벤트
        * 채널
            - 메세지는 채널을 통해서 교환
            - 송신자와 수신자가 채널을 통해 교환할 수 있는 메세지 갯수는 무제한
            - 종류
                - 1:1(점대점): 커맨드 메시지
                - 1:n(발행/구독): 이벤트 메시지

        * 통신 방식
            - (비동기) 요청/응답
                - 클라이언트가 메세지 id와 응답채널 id와 함께 요청하면, 서비스는 응답채널에 요청 메세지id와 함께 응답한다.
            - 단방향 알림
                - 서비스가 소유한 점대점 채널로 클라이언트가 커맨드 타입의 메세지를 보내면, 서비스는 이 채널을 구독해서 처리
            - 발행/구독
                - 여러 컨슈머에게 채널을 통해 클라이언트가 메시지 발행, 서비스는 도메인 변경 사실을 알리는 도메인 이벤트 발행
            - 발행/비동기 응답
                - 응답채널과 요청id를 클라이언트가 발행, 구독 서비스들은 요청 id를 포함한 응답 메시지를 지정된 채널로 응답
        * api 명세
            - 요청/ 비동기 응답: 서비스의 커맨드 메세지 채널, 서비스가 받는 커맨드 메시지 타입/포맷, 서비스가 반환하는 응답 메시지 타입/포맷
            - 단방향 알림 : 서비스 커맨드 메시지 채널, 서비스가 받는 커맨드 메시지 타입/포맷
            - 발행 이벤트 문서화: 이벤트 채널, 서비스가 채널에 발행하는 메시지의 타입/포맷
        * 기술
            - 브로커리스
                * 장점
                    - 서비스간 직접 통신으로 네트워크가 가벼움
                    - 메세지 브로커가 성능 병목점이 될 일이 없음
                    - 메세지 브로커의 운영 비용 절감
                * 단점
                    - 서비스가 서로의 위치를 알고 있어야 하므로, 서비스 디스커버리 방식 필요
                    - 송/수신자 모두 실행중이어야하므로 가용성이 떨어짐
                    - 전달보장 메커니즘을 구현하기 힘듦
            - 메세지 브로커
                * 메세지 브로커 선택시 고려할 점
                    - 프로그래밍 언어 지원 여부
                    - 메세지 표준 지원 여부: AMQP,STOMP 등 표준 프로토콜 지원 제품인지
                    - 메세지 순서 유지
                    - 전달 보장: 어떤 종류의 전달을 보장하는지
                    - 영속화: 브로커가 고장나도 문제가 없도록 메세지를 디스크에 저장하는지 여부
                    - 내구성: 컨슈머가 재접속 시, 접속 중단된 시간에 전달된 메세지 수신가능 여부
                    - 확장성
                    - 지연시간: 종단간 지연시간
                    - 경쟁사 컨슈머: 경쟁사의 컨슈머 지원 여부
                * 장점:
                    - 느슨한 결합: 서버와 클라이언트는 서로에 대해 몰라도 된다.
                    - 메세지 버퍼링: 동기방식과 다르게, 컨슈머가 다운되도, 브로커에 기록이 유지
                    - 유연한 통신: 모든 상호작용 스타일 지원
                    - 명시적 IPC: 
                * 단점
                    - 성능 병목 가능성: 브로커를 거치므로 성능상 불리
                    - 단일 장애점: 시스템 전반에 브로커의 영향이 커짐
                    - 운영 복잡도: 브로커 운영 비용
                * 수신자 경합과 메세지 순서 유지
                    - 메세지 순서를 유지한채 메세지 수신자를 수평확장할 수 있는 방안?
                    - 주문 생성, 변경, 삭제 이벤트를 여러 수신자가 동시에 처리한다면, 주문을 생성하기도 전에 삭제가 수행되는 에러 케이스 발생
                    - 샤딩/파티션 채널 이용
                        - 송신자의 샤딩키를 기준으로 샤딩 채널 배정
                        - 각 샤딩/파티션 채널은 하나의 수신자에게 배정
                * 중복 메세지
                    - 메세지를 한번만 송신하려면 비용이 크기때문에, 한번 이상 전송
                    - 주문 생성, 취소 이벤트 처리 시, 생성 이벤트를 응답하지 못한경우, 브로커는 원래 이벤트 순서를 유지하면서 재전송하는 방식이 이상적이다. 주문 생성만 재전송한다면, 취소된 주문을 다시 주문하는 경우가 발생할 수 있기 때문에, 주문 생성, 취소를 다시 재전송해주는 방식이 이상적이다.
                    - 해결방법
                        - 멱등한 메세지 핸들러: 동일 입력에 동일 출력
                        - 메세지 추적, 중복 메세지 필터: 처리 완료된 메세지 db insert
                * 트랜잭셔널 메세지: 트랙잭션 일부로 메세지를 발행
                    * 구성 방법
                        - 테이블을 메세지 큐로 활용: 트랜잭션으로 도메인 생성/수정/삭제 후 event 테이블 insert
                        - 이벤트 발행: (폴링) 이벤트 테이블을 폴링한 뒤 메세지 발행
                        - 이벤트 발행: 로그 테일링: db 트랜잭션 로그 항목을 트랜잭션 로그 마이너(transaction log miner)를 이용해 변경분을 하나씩 메세지로 발행
        * 가용성 개선
            - 동기 통신 (rest)의 경우 각 서비스의 가용성의 곱만큼 가용성이 저하된다. ( 예: 0.99^3 = 0.97)
            - 동기 api가 있는경우 데이터 복제 및 비동기 요청으로 해결할 수 있다.
                - 실제 필요한 데이터를 복제해서 가지고 있으면서, 이벤트를 통해 싱크를 맞춘다.
                - 클라이언트 요청 시, 가용한 데이터를 기반으로 응답 생성 후, 비동기 요청으로 검증에 필요한 나머지 부분을 체크한다.
                - 상태머신 (예: 주문 pending -> validating -> delivering -> finished)
                - **단점**: 클라이언트의 코드가 복잡해진다. 클라이언트 입장에서는 비동기 검증이 완료될때까지 폴링방식으로 조회하거나, 알림 메세지를 통해 상태를 추적해야한다.
